Using the lister functions - Elizabeth Mills - 28th August 2017
Revised - Elizabeth Mills - 11th April 2021
----------------------------------------------------------------

The scripts described herein are shared in the hope that they will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. A copy of the GNU General Public License is available from the lister page at:

   https://github.com/angeltoast/

   ... or write to:

   The Free Software Foundation, Inc.
   51 Franklin Street, Fifth Floor
   Boston, MA 02110-1301 USA
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Introduction
The lister scripts were originally developed as part of the independent Feliz installer for the Arch Linux operating system. Feliz moved onto Dialog, but lister remains as an independent project. lister is written entirely in bash, so you can edit it to suit your purposes.

In this guide, aimed at intermediate scripters, we will look at how the functions in the lister module can be incorporated to help you to improve the display of information while running your own scripts.

The lister module is self-contained and application-independent. It initialises all its own variables, and contains all the functions it needs; any of the functions may be called independently from any scripts. You only have to put a copy of the lister.sh module in the same location as your scripts, and source it, to be able to add all the features of lister to your scripts.

About The lister functions
lister is designed to help with creating intuitive cli interfaces without using Dialog, Whiptail, or any other external package. Instead, the tput library is used to determine the terminal dimensions and to display lists and text centrally according to content.

The functions are named distinctively, so that they stand out in your code:
CallForm
CallMessage
CallHeading:    Prepares a blank window with a heading;
CallFirstItem:  Prints one line, centralised on the page;
CallNextItem:   Prints successive items, aligned to the first;
CallPrintRev:   Reverses (ie: highlights) text colour for selected menu item and/or button;
CallButtons:    Prints a button or row of buttons (currently limited to two);
CallActiveMenu: Controls the selection and highlighting of menu items;
CallMenu:       Generates a menu of one-word items;
CallLongMenu:   Generates a menu of multi-word items;
CallLister:     Generates a page or pages of numbered items, for lists that would exceed screen size;
CallSelectPage: Selects an appropriate page of data according to user input;
CallPrintPage:  Displays one page of a list, fitting as many columns as possible in the window size.

A simple example, using the 'CallButtons' function
CallButtons can be used to generate an interactive Yes/No display.
A call to CallButtons uses three arguments:
1) Type (Menu, Yes/No);
2) Button string. This should contain one or two words: eg: 'Ok' or 'Ok Exit'
3) Message string.

At the time of writing, Buttons is limited to displaying only two buttons, but this may be extended to three options in the future.

Call Buttons with a line like this:
Buttons "Yes/No" "Yes No" "Use arrow keys to move. [Enter] to select"
The arguments in the example above inform the Buttons function of the type of operation, that the the buttons are to be labelled 'Yes' and 'No', and a short line of guidance to the user is to be displayed. 

lister1
The first and simplest listing function, lister1, is for use in shell scripts to generate an interactive menu. It prints the list of options provided, in the form of a scrollable menu, with a pair of 'buttons' to confirm or exit.
Arguments:
1)  A simple string array variable of the items to be listed;
2) An optional one-line string of text to be displayed beneath the 'buttons', advising the user how to use the menu. If this argument is passed as an empty string, the menu will display without the instructions line. This is for situations where a menu may be close to filling the screen, or where no instructions are necessary;
3) Button text eg: 'Ok Exit' or just 'Ok'. These must be single-word options. If only one word is passed (eg: 'Ok') then no exit option will be printed; in this way you can make sure that your users pick one of the menu items offered.

A call to lister1 takes the form ...
lister1 "argument1" "argument2" "argument3"
All three arguments must be passed, although the second argument can be an empty string, if no message is required.

Example call:
lister1 "Reboot Shutdown" "" "Ok Exit"

The first (string array) argument may be passed in one of three ways:
1) It may be specified in the calling line (as above):
	lister1 "item1 item2 item3 ... "
2) It may be assigned to a variable:
	VariableName="item1 item2 item3 ... "
	For example ...
      	Accessories="Conky Geany Nautilus Terminator"
	lister1 "$Accessories"
3) It may be generated by a bash command ...
      	For example …
	Partitionlist=$(lsblk -l | grep 'part')
	lister1 "$Partitionlist" "" "nocancel"
      Note: A bash-generated list should be converted to a string array. For example:
	Zones=(`timedatectl list-timezones | sed 's/\/.*$//' | uniq`)
	passzones=""
	for z in ${Zones[@]}; do
	    passzones="$passzones $z"
	done
	 ...
	lister1 "${passzones}" "" "nocancel"
lister1 sets two global variables for use by the calling function ...
1) $Response - the item number selected by the user, and
2) $Result - the label (from the variable array) of the item selected.
This means that you can respond to the user input by using (for example) a 'case - esac' statement or an 'if – else- fi' statement.

lister2
lister2 is designed for displaying longer descriptions in a menu. It receives the text of the long items via an array. When an item is selected, lister2 finds that item in a reference array of short (one-word) names that match the array of long-descriptions, and saves it as the global variable $Result which may then be used by the calling function if desired. Although complex to set up, it adds greater functionality and user-friendliness for menus. The reference array must be specifically declared, and the elements filled, before it can be used.
Calling lister2 takes the form:
lister2 "$PrimaryFile" "argument2" "argument3" "ReferenceArray"
Arguments:
Calling lister2 is similar to calling lister1, but with one added argument:
 1) The primary file. That is, a string of single-word references, as with lister1;
 2) A short message to be displayed to help the user. This may be left empty;
 3) The button text eg: 'Ok Exit' or just 'Ok';
 4) The name (only) of the reference array (this will be used to access the array).
Four arguments MUST be passed, although argument2 may be a null string.
lister2 returns the same global variables as lister1 and uses the same built-in functions

listerx
listerx differs from the other two, in that, instead of a cursor-driven menu, it generates a numbered list from which the user can choose by entering the number displayed next to the item. This is provided for situations where a large number of options is to be offered, and a lister1 or lister2 menu would scroll off the screen.
Because listerx must redraw the screen for each pageful of data to be displayed, it must be provided with all the text it needs for user advice and prompting. As a result, listerx requires five arguments
Before calling listerx, the calling function must generate a file containing the items to be displayed. The items in the file must be only one word each, must be one to a line, and the file must be named input.file.
The input.file may be generated in any way that produces a list of items, one on each line:
1) It may be passed directly:
printf "%-s\n" "item1" "item2" "item3" > input.file
2) It may be generated in a loop: 
for i in names.list
do
    echo $i >> input.file
done
3) It may be generated by a bash command ...
lsblk -l | grep 'part' > input.file

The calling function can send optional 'Headline' string as:
      # $1, to appear at the top of the screen, and an optional 'Message' as
      # $2, to appear at the bottom of the screen. $3, $4 and $5 are prompts

listerx is called in the form:
listerx "argument1" "argument2" "argument3" "argument4" "argument5"
argument1 is an optional string of text to be displayed at the top of the screen as information for the user. If passed as a null string, no message will be printed;
argument2 is an optional instruction line to appear at the prompt, which will be printed at the bottom of the terminal/screen, beneath the pageful of data – for example:
"Please enter the number of your selection: "
If argument1 is empty, no instruction will be printed – this could be confusing for the user, so it is advised that a message similar to that above is sent;
The remaining three arguments are paging advice:
argument3 allows for the user to back out of listerx and return to the calling function without making a selection – for example:
"or ' ' to go back"
argument4 and argument5 inform the user that they can page forwards or back through the data by entering either '>' for the next page, or '<' for the previous page. listerx will intelligently display these messages only if appropriate for the circumstances (ie: it will not suggest '>' if there are no more pages to be displayed. The arguments may be as follows:
"Enter '<' for previous page"
"Enter '>' for next page"
listerx will display as many columns as can be fitted onto the width of the terminal, instructing the user to enter a number for the item selected, or < or > to display the previous or next page of data, if relevant.
listerx sets the same output variables as lister1 and lister2

Further Developments
Feliz is in constant development, and has recently become multi-lingual, but great care has been taken to keep lister separate from the translation code. This is so that you can use lister in any situation. Nevertheless, in lister, as in Feliz, prompts and button-text were all in English, and an extensive rewrite of the lister functions has been necessary to allow any calling functions to specify exactly the text to be displayed in and below the lists.

Details of the implementation of translation capability into Feliz and lister will form the basis of another small book, for those of you who may like to examine and experiment with it.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Email: elizabeth@itsliz.net
Website: www.itsliz.net
~~~~~~~~~~~~~~~~~~~~~~~~~~~~